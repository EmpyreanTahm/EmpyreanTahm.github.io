const e={map:'[{"requestanimationframe":["3.0"],"用法":["3.1"],"性能":["3.2"],"兼容性":["3.3"],"总结":["3.4"],"语法":["3.5"],"参数":["3.6"],"返回值":["3.7"],"优点":["3.8"],"e":["6.0"],"基本使用":["6.1"],"浅谈":["7.0"],"引用计数":["7.1"],"小结":["7.2","7.5","7.13"],"可达性":["7.3"],"标记清除":["7.4"],"v8":["7.6","7.7"],"辅助线程":["7.8"],"增量标记":["7.9"],"三色标记法":["7.10"],"强制三色不变性":["7.11"],"惰性清理":["7.12"],"识别内存泄漏":["7.14"]},{"使用":["3.0","7.14"],"setinterval":["3.0"],"或":["3.0"],"requestanimationframe":["3.1","3.2","3.3","3.4"],"的用法很简单":["3.1"],"只需要传入一个回调函数作为参数":["3.1"],"的性能优势主要体现在以下几个方面":["3.2"],"它可以根据浏览器的刷新率来调整动画帧率":["3.2","3.4"],"从而保证动画的流畅性":["3.2"],"一般来说":["3.2"],"浏览器的刷新率是":["3.2"],"的兼容性还不是很好":["3.3"],"目前只有最新版本的主流浏览器支持它":["3.3"],"如果要在不支持的浏览器中使用它":["3.3"],"我们需要使用":["3.3"],"polyfill":["3.3"],"来模拟它":["3.3"],"是一个非常有用的方法":["3.4"],"可以让我们创建流畅和高效的动画效果":["3.4"],"它有以下几个特点和优势":["3.4"],"保证动画的流畅性":["3.4"],"它可以在后台标签页或隐藏的":["3.4"],"iframe":["3.4"],"js":["3.5"],"callback":["3.6"],"一个":["3.7"],"电池友好":["3.8"],"node":["6.0"],"gaugechart":["6.1"],"gaugedata":["6.1"],"gc":["7.0","7.6","7.8","7.9","7.11"],"程序的运行需要内存":["7.0"],"只要程序提出要求":["7.0"],"操作系统或者运行时就必须供给内存":["7.0"],"程序运行过程中申请的内存大于系统能够提供的内存":["7.0"],"导致程序无法申请到足够的内存":["7.0"],"会造成内存溢出":["7.0"],"out":["7.0"],"引用计数是":["7.1"],"被弃用":["7.1"],"的垃圾回收策略":["7.1"],"引用计数将":["7.1"],"对象不再需要":["7.1"],"与":["7.1"],"对象不被任何对象引用":["7.1"],"挂钩":["7.1"],"跟踪记录每个变量值被引用的次数":["7.1"],"声明变量":["7.1"],"并将引用类型值赋值给该变量":["7.1"],"引用次数为":["7.1"],"引用计数的优点在于容易实现":["7.2"],"当对象不再被引用时":["7.2"],"reachability":["7.3"],"为理解标记清除策略":["7.3"],"需要先了解":["7.3"],"mark":["7.4"],"and":["7.4"],"sweep":["7.4"],"引用计数和标记清除在释放内存后":["7.5"],"剩余对象的内存位置依旧不变":["7.5"],"会导致空闲内存空间不连续":["7.5"],"出现许多内存碎片":["7.5"],"剩余空闲内存不是一整块":["7.5"],"而是由不同大小内存组成的内存列表":["7.5"],"的分代回收":["7.6"],"垃圾清理算法会定时检查内存中所有的对象":["7.6"],"并对可达对象进行标记":["7.6"],"其问题在于":["7.6"],"一些对象常驻内存":["7.6"],"可能伴随代码的整个生命周期":["7.6"],"频繁检测这一类对象耗费性能":["7.6"],"的分代回收对不同类型的对象使用不同的回收机制和频率":["7.6"],"很大程度提高了":["7.6"],"的增量标记与惰性清理":["7.7"],"如果执行一次完整":["7.8"],"的时间过长":["7.8"],"就可能造成运行卡顿":["7.8"],"增量标记就是将原本一次完整":["7.9"],"标记":["7.9"],"之前介绍的标记清除将可达性的对象进行标记":["7.10"],"不可达对象不予理睬":["7.10"],"这实际上一种非黑即白的二色标记法":["7.10"],"在一小次":["7.11"],"标记后":["7.11"],"主线程执行任务时":["7.11"],"可能会修改对象的引用关系":["7.11"],"reference":["7.11"],"增量标记只对活动对象和非活动对象进行标记":["7.12"],"可以看出":["7.13"],"增量标记和惰性清理的引入":["7.13"],"并没有减少":["7.13"],"在浏览器开发者工具中":["7.14"],"performance":["7.14"],"和":["7.14"],"memory":["7.14"],"功能":["7.14"],"都可以帮助开发者查看内存占用":["7.14"],"如果内存占用不是趋于平稳":["7.14"]},{"0":["7.1"],"1":["7.1","7.6"],"60":["3.2"],"settimeout":["3.0"],"完成动画的核心是来定时更新动画的状态和渲染":["3.0"],"这种方法看起来很简单":["3.0"],"就可以让浏览器在下一次重绘之前执行这个回调函数":["3.1"],"例如":["3.1"],"我们可以使用以下代码来改写上面的移动方块的动画":["3.1"],"这里有几点需要注意":["3.1"],"60hz":["3.2"],"也就是每秒":["3.2"],"帧":["3.2"],"所以":["3.2"],"是一种代码片段":["3.3"],"可以让旧版本的浏览器支持新的特性或方法":["3.3"],"一个简单的":["3.3"],"的":["3.3","7.3"],"如下":["3.3"],"javascript":["3.3"],"判断是否已经存在":["3.3"],"中暂停动画":["3.4"],"节省资源和电池寿命":["3.4"],"它可以":["3.4"],"window":["3.4"],"告诉浏览器":["3.4"],"你希望执行一个动画":["3.4"],"并且要求浏览器在下次重绘之前调用指定的回调函数更新动画":["3.4"],"requestanimationframe":["3.5"],"当你的动画需要更新时":["3.6"],"为下一次重绘所调用的函数":["3.6"],"long":["3.7"],"整数":["3.7"],"eventloop":["6.0"],"height":["6.1"],"of":["7.0"],"memory":["7.0"],"不再用到的内存":["7.0"],"没有及时释放":["7.0"],"就叫做内存泄漏":["7.0"],"leak":["7.0"],"js":["7.0","7.3","7.14"],"同一引用类型值被赋值给另一变量":["7.1"],"引用次数":["7.1"],"同一引用类型值被其它值覆盖":["7.1"],"当值的引用次数变为":["7.1"],"时":["7.1"],"说明没有变量在使用值":["7.1"],"无法被访问":["7.1"],"其内存会被立即释放":["7.2"],"由于释放操作是针对每个对象个别执行的":["7.2"],"的概念":["7.3"],"node":["7.3","7.14"],"是目前":["7.4"],"es":["7.4","7.7"],"引擎中最常用的":["7.4"],"gc":["7.4","7.13"],"在分配大小为":["7.5"],"size":["7.5"],"的内存时":["7.5"],"需要对空闲内存列表进行一次单向遍历找出":["7.5"],"的块才能为其分配":["7.5"],"主要的三种分配策略":["7.5"],"的效率":["7.6","7.8"],"area":["7.6"],"引擎将堆内存分成多个区域":["7.6"],"新生代和老生代区域采用不同的策略管理垃圾回收":["7.6"],"新生代的对象为新产生的":["7.6"],"存活时间较短的对象":["7.6"],"新生代通常只支持":["7.6"],"8m":["7.6"],"的容量":["7.6"],"为提高":["7.8"],"v8":["7.8","7.12"],"采用多个辅助线程同时执行":["7.8"],"只是标记":["7.9"],"不包括回收":["7.9"],"的过程":["7.9"],"分成多次与主线程任务交替执行":["7.9"],"三色标记法维护一个标记工作表":["7.10"],"并对每个对象使用两个标记位进行标记":["7.10"],"两个标记位编码白":["7.10"],"灰":["7.10"],"modification":["7.11"],"上图中的":["7.11"],"c":["7.11"],"对象不再具备可达性":["7.11"],"在这一轮的":["7.11"],"实际还需要清理释放内存":["7.12"],"占用主线程的时间":["7.13"],"实际上":["7.13"],"而是随时间一直上升":["7.14"],"则可能发生了内存泄漏":["7.14"],"提供的":["7.14"],"process":["7.14"],"memoryusage":["7.14"],"方法执行后返回一个对象":["7.14"]},{"0":["3.3"],"1":["7.0"],"2":["7.0","7.1"],"3":["7.0","7.1"],"4":["7.1"],"500":["6.1"],"但实际上有很多问题":["3.0"],"首先":["3.0"],"它不能保证动画的流畅性":["3.0"],"因为定时器的执行时间和浏览器的渲染时间可能不一致":["3.0"],"回调函数会接收一个参数":["3.1"],"timestamp":["3.1"],"表示当前时间与页面加载时间的差值":["3.1"],"的回调函数也会每秒执行":["3.2"],"次":["3.2"],"但是":["3.2"],"如果浏览器的刷新率低于":["3.2"],"if":["3.3"],"window":["3.3","7.3"],"定义变量":["3.3"],"var":["3.3"],"lasttime":["3.3"],"创建":["3.3"],"该方法需要传入一个回调函数作为参数":["3.4"],"该回调函数会在浏览器下一次重绘之前执行":["3.4"],"tip":["3.4"],"备注":["3.4"],"若你想在浏览器下次重绘之前继续更新下一帧动画":["3.4"],"那么回调函数自身必须再次调用":["3.4"],"callback":["3.5"],"该回调函数会传入":["3.6"],"domhighrestimestamp":["3.6"],"请求":["3.7"],"id":["3.7"],"order":["6.0"],"details":["6.1"],"let":["7.0","7.1"],"obj":["7.0"],"prop":["7.0"],"value":["7.0"],"gc":["7.1","7.2"],"在运行时会清理掉引用次数为":["7.1"],"的值占用的内存":["7.1"],"js":["7.1"],"arr":["7.1"],"console":["7.1"],"log":["7.1"],"由":["7.2"],"而产生的中断时间就比较短":["7.2"],"global":["7.3"],"对象和":["7.3"],"javascript":["7.3"],"策略":["7.4"],"各大浏览器的":["7.4"],"算法都是基于标记清除的改进和优化":["7.4"],"标记清除从根对象开始":["7.4"],"first":["7.5"],"fit":["7.5"],"找到":["7.5"],"的块立即返回":["7.5"],"best":["7.5"],"老生代的对象为存活事件较长或常驻内存的对象":["7.6"],"它们是经历过新生代垃圾回收后还存活下来的对象":["7.6"],"老生代容量通常比较大":["7.6"],"新生代对象通过":["7.6"],"scavenge":["7.6"],"算法进行":["7.6"],"算法主要采用":["7.6"],"cheney":["7.6"],"算法":["7.6"],"是单线程语言":["7.7"],"只有一个主线程":["7.7"],"parallel":["7.8"],"新生代空间就采用辅助线程进行回收":["7.8"],"在":["7.8"],"increase":["7.9"],"mark":["7.9"],"将一次完整的":["7.9"],"黑三种颜色":["7.10"],"白":["7.10"],"未被标记":["7.10"],"中":["7.11"],"它不会标记和清理":["7.11"],"不过完全可以等待下轮":["7.11"],"处理它":["7.11"],"但是新的对象":["7.11"],"清理释放内存采用惰性清理":["7.12"],"v8":["7.13"],"采用":["7.13"],"并发标记":["7.13"],"多个辅助线程在后台完成标记工作":["7.13"],"包含了":["7.14"],"进程的内存占用信息":["7.14"],"该对象包含四个字段":["7.14"],"单位是":["7.14"],"byte":["7.14"],"判断内存泄漏":["7.14"],"以":["7.14"]},{"0":["7.4"],"2":["7.6","7.9"],"4":["7.0"],"5":["7.0"],"60":["3.4"],"37306368":["7.14"],"导致动画出现卡顿或掉帧的现象":["3.0"],"其次":["3.0"],"它不能保证动画的高效性":["3.0"],"单位为毫秒":["3.1"],"我们可以利用这个参数来计算动画的状态和速度":["3.1"],"我们需要在回调函数中再次调用":["3.1"],"或者设备的性能不足":["3.2"],"那么":["3.2"],"的回调函数会相应地减少执行次数":["3.2"],"以避免动画卡顿或掉帧":["3.2"],"它可以在后台标签页或隐藏的":["3.2"],"function":["3.3"],"callback":["3.3"],"获取当前时间":["3.3"],"now":["3.3"],"date":["3.3"],"是一次性的":["3.4"],"当你准备更新在屏动画时你应该调用此方法":["3.4"],"这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数":["3.4"],"即你的回调函数":["3.4"],"回调函数执行次数通常是每秒":["3.4"],"次":["3.4"],"但在大多数遵循":["3.4"],"该参数与":["3.6"],"是回调列表中唯一的标识":["3.7"],"show":["6.1"],"code":["6.1"],"以上代码在执行时":["7.0"],"栈内存中存放指针":["7.0"],"指向堆内存中的对象实体":["7.0"],"hello":["7.1"],"world":["7.1"],"null":["7.1"],"数组":["7.1"],"是一个值":["7.1"],"会占用内存":["7.1"],"变量":["7.1"],"引用计数最大的缺点是无法释放循环引用的对象":["7.2"],"同时":["7.2"],"对象":["7.3"],"被称作":["7.3"],"根":["7.3"],"将具有可达性的对象用递归的方式进行标记":["7.4"],"然后将没有标记到的对象作为垃圾进行回收":["7.4"],"根据标记清除算法":["7.4"],"遍历整个空闲列表":["7.5"],"返回":["7.5"],"的最小分块":["7.5"],"worst":["7.5"],"算法将新生代分为":["7.6"],"个同样大小的空间":["7.6"],"处于使用状态的空间称为":["7.6"],"from":["7.6"],"闲置的空间称为":["7.6"],"to":["7.6"],"产生的新对象进入":["7.6"],"检查":["7.6"],"gc":["7.7"],"过程中":["7.8"],"会启动多个线程来负责新生代中的垃圾清理操作":["7.8"],"这些线程同时将":["7.8"],"标记分次执行造成":["7.9"],"个主要问题":["7.9"],"每一小次":["7.9"],"自身被标记":["7.10"],"成员对象未被标记":["7.10"],"黑":["7.10"],"d":["7.11"],"初始是白色":["7.11"],"本轮的下一次":["7.11"],"标记时":["7.11"],"由于没有灰色节点":["7.11"],"lazy":["7.12"],"sweeping":["7.12"],"并发的优点是不占用主线程":["7.13"],"但多个线程的协同需要锁机制来保障":["7.13"],"simultaneous":["7.13"],"heapused":["7.14"],"字段为准":["7.14"],"rss":["7.14"],"heaptotal":["7.14"]},{"3":["7.6"],"16":["3.3"],"17422":["7.14"],"1005812":["7.14"],"6185232":["7.14"],"7892992":["7.14"],"因为定时器会一直执行":["3.0"],"即使浏览器处于后台或隐藏状态":["3.0"],"也会消耗资源和电池寿命":["3.0"],"最后":["3.0"],"来请求下一次动画帧":["3.1"],"从而形成一个循环":["3.1"],"否则":["3.1"],"动画只会执行一次":["3.1"],"iframe":["3.2"],"中暂停动画":["3.2"],"从而节省资源和电池寿命":["3.2"],"这是因为浏览器会根据页面的可见性来决定是否执行":["3.2"],"的回调函数":["3.2"],"计算下一次执行时间":["3.3"],"nexttime":["3.3"],"math":["3.3"],"max":["3.3"],"w3c":["3.4"],"建议的浏览器中":["3.4"],"回调函数执行次数通常与浏览器屏幕刷新次数相匹配":["3.4"],"为了提高性能和电池寿命":["3.4"],"在大多数浏览器里":["3.4"],"当":["3.4"],"运行在后台标签页或者隐藏的":["3.4"],"performance":["3.6"],"now":["3.6"],"是个非零值":["3.7"],"没有别的意义":["3.7"],"vue":["6.1"],"template":["6.1"],"被重新赋值一个数组时":["7.0"],"栈中的指针指向堆内存中新的数组实体":["7.0"],"是仅有的对这个值的引用":["7.1"],"因此这个数组的被引用次数为":["7.1"],"尽管后面的代码没有用到":["7.1"],"但数组还是会持续占用内存":["7.1"],"如果执行":["7.1"],"就解除了":["7.1"],"引用计数也不适合并行处理":["7.2"],"如果多个线程同时对引用计数进行增减的话":["7.2"],"引用计数的值就可能会不一致":["7.2"],"可达值":["7.3"],"指":["7.3"],"存储在内存中的":["7.3"],"可访问或可用的值":["7.3"],"当前执行函数的局部变量和参数":["7.3"],"引用的对象一定会被回收":["7.4"],"而需要被回收的对象却不一定是零引用":["7.4"],"前述":["7.4"],"marry":["7.4"],"找到最大的分块":["7.5"],"将其切成两部分":["7.5"],"其中一部分大小为":["7.5"],"并将该部分返回":["7.5"],"memory":["7.5"],"是否已满":["7.6"],"已满执行":["7.6"],"标记":["7.6"],"中的活动对象":["7.6"],"标记完成之后":["7.6"],"将":["7.6"],"会阻塞脚本的执行":["7.7"],"这种行为叫全停顿":["7.7"],"from":["7.8"],"的对象移动到":["7.8"],"to":["7.8"],"在这个过程中":["7.8"],"由于对象地址会发生改变":["7.8"],"标记执行完之后":["7.9"],"如何暂停下来去执行任务程序":["7.9"],"而后又怎么恢复":["7.9"],"自身和成员变量皆被标记":["7.10"],"tri":["7.10"],"color":["7.10"],"marking":["7.10"],"因此会认为标记结束":["7.11"],"对象会在本轮":["7.11"],"的清理阶段被回收":["7.11"],"为防止以上情况的发生":["7.11"],"增量标记完成后":["7.12"],"如果内存空间足够":["7.12"],"新生代优化":["7.13"],"scavenge":["7.13"],"算法":["7.13"],"external":["7.14"],"arraybuffers":["7.14"],"resident":["7.14"]},{"4":["7.6"],"5":["7.6"],"它不能保证动画的灵活性":["3.0"],"因为定时器的频率是固定的":["3.0"],"不能根据不同的设备和环境进行调整":["3.0"],"我们可以使用":["3.1"],"cancelanimationframe":["3.1"],"来取消已经请求的动画帧":["3.1"],"如果页面不可见":["3.2"],"那么回调函数就不会执行":["3.2"],"直到页面再次可见时恢复执行":["3.2"],"它可以避免动画和其他任务的冲突":["3.2"],"从而提高动画的稳定性":["3.2"],"这是因为":["3.2"],"返回定时器编号":["3.3"],"return":["3.3"],"settimeout":["3.3"],"执行回调函数":["3.3"],"里时":["3.4"],"会被暂停调用以提升性能和电池寿命":["3.4"],"domhighrestimestamp":["3.4"],"参数会传入回调方法中":["3.4"],"它指示当前被":["3.4"],"的返回值相同":["3.6"],"它表示":["3.6"],"你可以传这个值给":["3.7"],"window":["3.7"],"对象实体":["7.0"],"不会再被使用到":["7.0"],"应该清理其所占的内存空间":["7.0"],"如果没有对不再使用的内存空间进行清理":["7.0"],"就会发生内存泄漏":["7.0"],"对":["7.1"],"的引用":["7.1"],"引用次数变成了":["7.1"],"这部分内存就可以被垃圾回收器释放":["7.1"],"以下代码执行完后":["7.1"],"由两个参数对象由于互相引用使得其引用计数为":["7.1"],"导致内存错误":["7.2"],"为了避免这种情况的发生":["7.2"],"当前嵌套调用链上的其它函数和它们的局部变量和参数":["7.3"],"全局变量":["7.3"],"可通过根对象访问的值":["7.3"],"如全局对象的一个属性是另一个对象":["7.3"],"函数执行完毕之后":["7.4"],"尽管函数作用域中的对象存在循环引用":["7.4"],"但这个函数作用域整体不具备可达性":["7.4"],"即通过根对象始终无法访问":["7.4"],"因此这个函数作用域整体会成为一个孤岛而不被标记":["7.4"],"内存碎片化导致需要遍历空闲内存列表":["7.5"],"选取最适合的内存进行分配":["7.5"],"即使是":["7.5"],"分配策略":["7.5"],"时间复杂度也是":["7.5"],"的活动对象复制进":["7.6"],"并进行排序":["7.6"],"清理":["7.6"],"区域":["7.6"],"和":["7.6"],"stop":["7.7"],"所以还需要同步更新引用这些对象的指针":["7.8"],"不过好在这个":["7.8"],"过程是一个整体":["7.8"],"只需要考虑协同问题":["7.8"],"假如在一次完整的":["7.9"],"标记分块暂停后":["7.9"],"执行任务程序时内存中标记好的对象引用关系被修改了怎么办":["7.9"],"在恢复":["7.10"],"gc":["7.10"],"标记时":["7.10"],"v8":["7.11"],"增量回收使用了":["7.11"],"写屏障":["7.11"],"write":["7.11"],"barriers":["7.11"],"机制":["7.11"],"不影响代码的执行":["7.12"],"辅助线程":["7.13"],"老生代优化":["7.13"],"主线程执行程序任务":["7.13"],"set":["7.14"],"size":["7.14"],"所有内存占用":["7.14"],"包括指令区和堆栈":["7.14"],"堆":["7.14"],"占用的内存":["7.14"],"包括用到的和没用到的":["7.14"]},{"25":["7.6"],"为了解决这些问题":["3.0"],"html5":["3.0"],"提供了一个新的方法":["3.0"],"传入的参数是":["3.1"],"的返回值":["3.1"],"表示动画帧的编号":["3.1"],"的回调函数会在浏览器的主线程中执行":["3.2"],"但是它会在其他任务":["3.2"],"如事件处理":["3.2"],"dom":["3.2"],"操作":["3.2"],"cancelanimationframe":["3.3","3.7"],"cleartimeout":["3.3"],"这个":["3.3"],"的原理是使用":["3.3"],"排序的回调函数被触发的时间":["3.4"],"在同一个帧中的多个回调函数":["3.4"],"它们每一个都会接受到一个相同的时间戳":["3.4"],"即使在计算上一个回调函数的工作负载期间已经消耗了一些时间":["3.4"],"该时间戳是一个十进制数":["3.4"],"单位为毫秒":["3.4"],"最小精度为":["3.4"],"1ms":["3.4"],"requestanimationframe":["3.6"],"开始执行回调函数的时刻":["3.6"],"以取消回调函数请求":["3.7"],"内存泄漏的堆积":["7.0"],"会使内存占用越来越高":["7.0"],"轻则影响系统性能":["7.0"],"重则导致进程崩溃":["7.0"],"尤其是持续运行的服务进程":["7.0"],"daemon":["7.0"],"es":["7.0"],"具有自动垃圾回收":["7.0"],"会造成即使后续不会再被使用到":["7.1"],"也会持续占用内存":["7.1"],"不被释放":["7.1"],"这就是引用计数最大的缺点":["7.1"],"无法处理循环引用":["7.1"],"function":["7.1"],"marry":["7.1"],"man":["7.1"],"woman":["7.1"],"wife":["7.1"],"对引用计数的操作必须采用独占的方式来进行":["7.2"],"如果引用操作频繁发生":["7.2"],"每次都要使用加锁等并发控制机制的话":["7.2"],"这个属性指向的对象是可达的":["7.3"],"可达值在函数作用域的定义都使用了":["7.3"],"当前执行":["7.3"],"进行限制":["7.3"],"实际上":["7.3"],"等待":["7.4"],"unreachable":["7.4"],"tip":["7.4"],"o":["7.5"],"n":["7.5"],"垃圾回收会导致后续对象":["7.5"],"尤其是大对象的内存分配效率变慢":["7.5"],"标记整理":["7.5"],"mark":["7.5"],"compact":["7.5"],"角色互换":["7.6"],"在执行以上第":["7.6"],"步时":["7.6"],"如果发现":["7.6"],"对象已经历过多次复制":["7.6"],"直接晋升到老生代":["7.6"],"对象会占用":["7.6"],"空间":["7.6"],"the":["7.7"],"world":["7.7"],"辅助线程还是一种全停顿的":["7.8"],"方式":["7.8"],"老生代由于存在的对象多且大":["7.8"],"采用辅助线程依然会消耗大量时间":["7.8"],"为解决增量标记带来的问题":["7.9"],"v8":["7.9","7.14"],"采用":["7.9"],"三色标记法":["7.9"],"如果没有灰色节点":["7.10"],"说明本次":["7.10"],"标记工作完成":["7.10"],"即一旦有黑色对象引用白色对象":["7.11"],"会强制将该白对象置灰":["7.11"],"从而保证本轮的下一次":["7.11"],"标记正常执行":["7.11"],"这个机制也被称作":["7.11"],"没有必要立即清理":["7.12"],"可以适当延迟清理从而让步于脚本的执行":["7.12"],"辅助线程同时执行标记操作":["7.13"],"并行清理":["7.13"],"主线程执行清理时":["7.13"],"用到的堆占用的内存":["7.14"],"引擎内部的":["7.14"],"c":["7.14"],"对象占用的内存":["7.14"],"分配给":["7.14"]},{"60":["3.3"],"这个方法可以让浏览器在合适的时间来执行动画的回调函数":["3.0"],"从而实现流畅和高效的动画效果":["3.0"],"这样可以在不需要动画时停止动画":["3.1"],"节省资源":["3.1"],"网络请求等":["3.2"],"之后":["3.2"],"渲染之前执行":["3.2"],"这样可以保证动画的状态和渲染的一致性":["3.2"],"避免出现闪烁或抖动等问题":["3.2"],"来模拟":["3.3"],"但是它会根据上一次执行时间来计算下一次执行时间":["3.3"],"从而尽量保持每秒":["3.3"],"帧的效果":["3.3"],"1000μs":["3.4"],"warning":["3.4"],"警告":["3.4"],"请确保总是使用第一个参数":["3.4"],"或其他一些获取当前时间的方法":["3.4"],"来计算动画在一帧中的进度":["3.4"],"否则动画在高刷新率的屏幕中会运行得更快":["3.4"],"garbage":["7.0"],"collecation":["7.0"],"机制":["7.0"],"宿主环境会负责内存的分配和回收":["7.0"],"垃圾回收器会按照固定的时间间隔":["7.0"],"周期性地找出不再继续使用的变量":["7.0"],"然后释放其占用的内存":["7.0"],"husband":["7.1"],"return":["7.1"],"name":["7.1"],"john":["7.1"],"ann":["7.1"],"其开销也是不可小觑的":["7.2"],"在函数在执行完毕后":["7.3"],"如果没有返回函数造成闭包":["7.3"],"那么此时整个函数作用域将不具备可达性":["7.3"],"归纳":["7.4"],"无论哪种回收策略":["7.4"],"全局变量永远不会被当成垃圾回收":["7.4"],"算法可以有效解决这个问题":["7.5"],"它会在标记结束后":["7.5"],"将被标记的对象向内存的一端移动":["7.5"],"最后清理边界的未被标记的内存":["7.5"],"align":["7.5"],"的大小":["7.6"],"晋升到老生代":["7.6"],"方便内存分配":["7.6"],"防止频繁复制":["7.6"],"老生代中主要是占用空间大":["7.6"],"存活时间久的对象":["7.6"],"它主要使用标记清除算法进行":["7.6"],"并用标记整理算法解决内存碎片化的问题":["7.6"],"对老生代的优化主要是增量标记与惰性清理":["7.6"],"对于老生代空间":["7.8"],"采用增量标记进行优化":["7.8"],"和":["7.9"],"写屏障":["7.9"],"进入清理阶段":["7.10"],"反之需要继续从灰色节点继续进行标记":["7.10"],"因此":["7.11"],"上述情况的":["7.11"],"对象会被强制改为灰色":["7.11"],"多个辅助线程也同时执行清理":["7.13"],"这个过程以增量的方式执行":["7.13"],"sharedarraybuffers":["7.14"],"的内存":["7.14"],"包括所有":["7.14"],"缓冲区":["7.14"]}]'},a={"3.0":{t:"# requestAnimationFrame\r",p:`使用 setInterval() 或 setTimeout() 完成动画的核心是来定时更新动画的状态和渲染。
这种方法看起来 ...`,l:"性能优化/requestAnimationFrame.html",a:"requestanimationframe"},"3.1":{t:"用法\r",p:"requestAnimationFrame 的用法很简单，只需要传入一个回调函数作为参数，就可以让浏览器在下一次重绘之前执行 ...",l:"性能优化/requestAnimationFrame.html#用法",a:"用法"},"3.2":{t:"性能\r",p:`requestAnimationFrame 的性能优势主要体现在以下几个方面：

它可以根据浏览器的刷新率来调整动画帧率，从 ...`,l:"性能优化/requestAnimationFrame.html#性能",a:"性能"},"3.3":{t:"兼容性\r",p:"requestAnimationFrame 的兼容性还不是很好，目前只有最新版本的主流浏览器支持它。如果要在不支持的浏览器中 ...",l:"性能优化/requestAnimationFrame.html#兼容性",a:"兼容性"},"3.4":{t:"总结\r",p:"requestAnimationFrame 是一个非常有用的方法，可以让我们创建流畅和高效的动画效果。它有以下几个特点和优势 ...",l:"性能优化/requestAnimationFrame.html#总结",a:"总结"},"3.5":{t:"语法\r",p:`requestAnimationFrame(callback)

`,l:"性能优化/requestAnimationFrame.html#语法",a:"语法"},"3.6":{t:"参数\r",p:`callback
当你的动画需要更新时，为下一次重绘所调用的函数。该回调函数会传入 DOMHighResTimeStamp  ...`,l:"性能优化/requestAnimationFrame.html#参数",a:"参数"},"3.7":{t:"返回值\r",p:"一个 long 整数，请求 ID，是回调列表中唯一的标识。是个非零值，没有别的意义。你可以传这个值给 window.canc ...",l:"性能优化/requestAnimationFrame.html#返回值",a:"返回值"},"3.8":{t:"优点\r",p:`
电池友好

`,l:"性能优化/requestAnimationFrame.html#优点",a:"优点"},"6.0":{t:"# E\r",p:`!Node-eventloop-order
`,l:"进阶篇/Event Loop.html",a:"e"},"6.1":{t:"基本使用\r",p:"&lt;GaugeChart :gaugeData=&quot;gaugeData&quot; :height=&quot; ...",l:"进阶篇/Event Loop.html#基本使用",a:"基本使用"},"7.0":{t:"# 浅谈 GC\r",p:"程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须供给内存。程序运行过程中申请的内存大于系统能够提供的内存，导致 ...",l:"进阶篇/浅谈 GC.html",a:"浅谈-gc"},"7.1":{t:"引用计数\r",p:"引用计数是被弃用的垃圾回收策略。引用计数将 “对象不再需要” 与 “对象不被任何对象引用” 挂钩，跟踪记录每个变量值被引用的 ...",l:"进阶篇/浅谈 GC.html#引用计数",a:"引用计数"},"7.2":{t:"小结\r",p:"引用计数的优点在于容易实现，当对象不再被引用时，其内存会被立即释放，由于释放操作是针对每个对象个别执行的，由 GC 而产生的 ...",l:"进阶篇/浅谈 GC.html#小结",a:"小结"},"7.3":{t:"可达性（Reachability）\r",p:"为理解标记清除策略，需要先了解 “可达性” 的概念。Node.js 的 global 对象和 JavaScript 的 wi ...",l:"进阶篇/浅谈 GC.html#可达性-reachability",a:"可达性-reachability"},"7.4":{t:"标记清除\r",p:"标记清除（Mark and Sweep）是目前 ES 引擎中最常用的 GC 策略，各大浏览器的 GC 算法都是基于标记清除的 ...",l:"进阶篇/浅谈 GC.html#标记清除",a:"标记清除"},"7.5":{t:"小结\r",p:`引用计数和标记清除在释放内存后，剩余对象的内存位置依旧不变，会导致空闲内存空间不连续，出现许多内存碎片。
剩余空闲内存不是一 ...`,l:"进阶篇/浅谈 GC.html#小结",a:"小结"},"7.6":{t:"V8 的分代回收\r",p:"垃圾清理算法会定时检查内存中所有的对象，并对可达对象进行标记。其问题在于，一些对象常驻内存，可能伴随代码的整个生命周期，频繁 ...",l:"进阶篇/浅谈 GC.html#v8-的分代回收",a:"v8-的分代回收"},"7.7":{t:"V8 的增量标记与惰性清理\r",p:`ES 是单线程语言，只有一个主线程，GC 会阻塞脚本的执行，这种行为叫全停顿（Stop The World）。
`,l:"进阶篇/浅谈 GC.html#v8-的增量标记与惰性清理",a:"v8-的增量标记与惰性清理"},"7.8":{t:"辅助线程\r",p:`如果执行一次完整 GC 的时间过长，就可能造成运行卡顿。为提高 GC 的效率，V8 采用多个辅助线程同时执行 GC。
!pa ...`,l:"进阶篇/浅谈 GC.html#辅助线程",a:"辅助线程"},"7.9":{t:"增量标记\r",p:`增量标记就是将原本一次完整 GC 标记（只是标记，不包括回收）的过程，分成多次与主线程任务交替执行。
!increase-m ...`,l:"进阶篇/浅谈 GC.html#增量标记",a:"增量标记"},"7.10":{t:"三色标记法\r",p:"之前介绍的标记清除将可达性的对象进行标记，不可达对象不予理睬，这实际上一种非黑即白的二色标记法。三色标记法维护一个标记工作表 ...",l:"进阶篇/浅谈 GC.html#三色标记法",a:"三色标记法"},"7.11":{t:"强制三色不变性\r",p:`在一小次 GC 标记后，主线程执行任务时，可能会修改对象的引用关系：
!reference-modification
上图中 ...`,l:"进阶篇/浅谈 GC.html#强制三色不变性",a:"强制三色不变性"},"7.12":{t:"惰性清理\r",p:"增量标记只对活动对象和非活动对象进行标记，实际还需要清理释放内存。V8 清理释放内存采用惰性清理（Lazy Sweeping ...",l:"进阶篇/浅谈 GC.html#惰性清理",a:"惰性清理"},"7.13":{t:"小结\r",p:"可以看出，增量标记和惰性清理的引入，并没有减少 GC 占用主线程的时间。实际上 V8 采用 “并发标记”，多个辅助线程在后台 ...",l:"进阶篇/浅谈 GC.html#小结",a:"小结"},"7.14":{t:"识别内存泄漏\r",p:"在浏览器开发者工具中，使用 Performance 和 Memory 功能，都可以帮助开发者查看内存占用，如果内存占用不是趋 ...",l:"进阶篇/浅谈 GC.html#识别内存泄漏",a:"识别内存泄漏"}},t={previewLength:62,buttonLabel:"Search",placeholder:"Search docs",allow:[],ignore:[]},r={INDEX_DATA:e,PREVIEW_LOOKUP:a,Options:t};export{r as default};
