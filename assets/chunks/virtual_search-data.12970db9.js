const e={map:'[{"requestanimationframe":["3.0"],"用法":["3.1"],"性能":["3.2"],"兼容性":["3.3"],"总结":["3.4"],"语法":["3.5"],"参数":["3.6"],"返回值":["3.7"],"优点":["3.8"],"event":["6.0"],"浏览器的事件循环":["6.1"],"调用栈":["6.2"],"任务队列":["6.3"],"宏任务":["6.4"],"微任务":["6.5"],"事件循环过程":["6.6"],"node":["6.7"],"关于":["6.8"]},{"1":["6.6"],"使用":["3.0"],"setinterval":["3.0"],"或":["3.0"],"requestanimationframe":["3.1","3.2","3.3","3.4"],"的用法很简单":["3.1"],"只需要传入一个回调函数作为参数":["3.1"],"的性能优势主要体现在以下几个方面":["3.2"],"它可以根据浏览器的刷新率来调整动画帧率":["3.2","3.4"],"从而保证动画的流畅性":["3.2"],"一般来说":["3.2"],"浏览器的刷新率是":["3.2"],"的兼容性还不是很好":["3.3"],"目前只有最新版本的主流浏览器支持它":["3.3"],"如果要在不支持的浏览器中使用它":["3.3"],"我们需要使用":["3.3"],"polyfill":["3.3"],"来模拟它":["3.3"],"是一个非常有用的方法":["3.4"],"可以让我们创建流畅和高效的动画效果":["3.4"],"它有以下几个特点和优势":["3.4"],"保证动画的流畅性":["3.4"],"它可以在后台标签页或隐藏的":["3.4"],"iframe":["3.4"],"js":["3.5","6.7"],"callback":["3.6"],"一个":["3.7"],"电池友好":["3.8"],"loop":["6.0"],"es":["6.0"],"的运行环境都采用了":["6.0"],"单线程":["6.0"],"模型":["6.0"],"在现代浏览器中":["6.1"],"一个标签页通常是一个独立的进程":["6.1"],"每个进程都可以包含多个线程":["6.1"],"浏览器有一个主线程":["6.1"],"调用栈是一个用于追踪函数调用的有限栈内存区域":["6.2"],"任务队列是一个遵循先进先出原则的队列":["6.3"],"在浏览器中":["6.3"],"定时器":["6.4"],"promise":["6.5"],"主线程":["6.6"],"指":["6.6"],"的事件循环":["6.7"],"事件循环由":["6.7"],"libuv":["6.7"],"库实现":["6.7"],"执行过程中的异步任务交由":["6.7"],"处理":["6.7"],"异步操作执行完成后":["6.7"],"poll":["6.8"],"阶段":["6.8"],"在":["6.8"],"i":["6.8"],"o":["6.8"],"的回调函数可能持续触发":["6.8"],"因此这个过程可能会阻塞后续阶段的回调执行":["6.8"],"为确保定时器的执行不会误差太多":["6.8"],"事件循环会使用定时器队列中最小的":["6.8"]},{"1":["6.7"],"60":["3.2"],"settimeout":["3.0","6.4","6.7"],"完成动画的核心是来定时更新动画的状态和渲染":["3.0"],"这种方法看起来很简单":["3.0"],"就可以让浏览器在下一次重绘之前执行这个回调函数":["3.1"],"例如":["3.1"],"我们可以使用以下代码来改写上面的移动方块的动画":["3.1"],"这里有几点需要注意":["3.1"],"60hz":["3.2"],"也就是每秒":["3.2"],"帧":["3.2"],"所以":["3.2"],"是一种代码片段":["3.3"],"可以让旧版本的浏览器支持新的特性或方法":["3.3"],"一个简单的":["3.3"],"的":["3.3"],"如下":["3.3"],"javascript":["3.3"],"判断是否已经存在":["3.3"],"中暂停动画":["3.4"],"节省资源和电池寿命":["3.4"],"它可以":["3.4"],"window":["3.4"],"告诉浏览器":["3.4"],"你希望执行一个动画":["3.4"],"并且要求浏览器在下次重绘之前调用指定的回调函数更新动画":["3.4"],"requestanimationframe":["3.5"],"当你的动画需要更新时":["3.6"],"为下一次重绘所调用的函数":["3.6"],"long":["3.7"],"整数":["3.7"],"这意味着任一时刻":["6.0"],"只能执行一个操作":["6.0"],"单线程的好处是":["6.0"],"不需要考虑并发和同步问题":["6.0"],"负责处理子线程的协调和调度":["6.1"],"这些子线程包括":["6.1"],"渲染线程":["6.1"],"负责页面的渲染和绘制":["6.1"],"包括布局计算":["6.1"],"当函数被调用时":["6.2"],"会被推入调用栈":["6.2"],"任务队列由浏览器内核或":["6.3"],"es":["6.3","6.6"],"await":["6.5"],"引擎线程":["6.6"],"执行同步任务":["6.6"],"入栈":["6.6"],"回调函数会被放入对应的任务队列中":["6.7"],"当":["6.7"],"启动时会初始化事件循环":["6.7"],"事件循环包含以下六个阶段":["6.7"],"这些阶段会依次执行":["6.7"],"timers":["6.7"],"执行到期的":["6.7"],"和":["6.7"],"setinterval":["6.7"],"timeout":["6.8"],"如果在执行":["6.8"],"时间后":["6.8"],"还有":["6.8"],"回调函数未执行":["6.8"],"事件循环会立即结束当前":["6.8"]},{"0":["3.3"],"2":["6.7"],"3":["6.7"],"但实际上有很多问题":["3.0"],"首先":["3.0"],"它不能保证动画的流畅性":["3.0"],"因为定时器的执行时间和浏览器的渲染时间可能不一致":["3.0"],"回调函数会接收一个参数":["3.1"],"timestamp":["3.1"],"表示当前时间与页面加载时间的差值":["3.1"],"的回调函数也会每秒执行":["3.2"],"次":["3.2"],"但是":["3.2"],"如果浏览器的刷新率低于":["3.2"],"if":["3.3"],"window":["3.3"],"定义变量":["3.3"],"var":["3.3"],"lasttime":["3.3"],"创建":["3.3"],"该方法需要传入一个回调函数作为参数":["3.4"],"该回调函数会在浏览器下一次重绘之前执行":["3.4"],"tip":["3.4"],"备注":["3.4"],"若你想在浏览器下次重绘之前继续更新下一帧动画":["3.4"],"那么回调函数自身必须再次调用":["3.4"],"callback":["3.5"],"该回调函数会传入":["3.6"],"domhighrestimestamp":["3.6"],"请求":["3.7"],"id":["3.7"],"避免竞态条件":["6.0"],"节省内存":["6.0"],"单线程的坏处在于":["6.0"],"无法利用多核":["6.0"],"cpu":["6.0"],"不适合":["6.0"],"绘制图形等任务":["6.1"],"es":["6.1"],"引擎线程":["6.1"],"负责解析和执行":["6.1"],"当函数执行完成后":["6.2"],"会从调用栈中弹出":["6.2"],"引擎创建和管理":["6.3"],"浏览器中包含两个主要的任务队列":["6.3"],"宏任务队列":["6.3"],"setinterval":["6.4"],"ui":["6.4"],"关键字后的":["6.5"],"出栈直到调用栈为空":["6.6"],"执行过程中的异步任务交由特定线程处理":["6.6"],"异步操作执行完成后":["6.6"],"的回调":["6.7"],"pending":["6.7","6.8"],"callbacks":["6.7","6.8"],"执行上一个循环的":["6.7"],"poll":["6.7"],"阶段还没来得及处理的回调":["6.7"],"idle":["6.7"],"prepare":["6.7"],"仅在":["6.7"],"内部使用":["6.7"],"并将剩余的回调函数放入":["6.8"],"队列":["6.8"],"由于回调函数本身是同步执行的":["6.8"],"如果某次回调函数执行时间过长":["6.8"],"那么定时器可能会有相当大的误差":["6.8"],"js":["6.8"],"const":["6.8"],"https":["6.8"],"require":["6.8"]},{"2":["6.6"],"3":["6.6"],"4":["6.7"],"5":["6.7"],"16":["6.8"],"60":["3.4"],"10240":["6.8"],"导致动画出现卡顿或掉帧的现象":["3.0"],"其次":["3.0"],"它不能保证动画的高效性":["3.0"],"单位为毫秒":["3.1"],"我们可以利用这个参数来计算动画的状态和速度":["3.1"],"我们需要在回调函数中再次调用":["3.1"],"或者设备的性能不足":["3.2"],"那么":["3.2"],"的回调函数会相应地减少执行次数":["3.2"],"以避免动画卡顿或掉帧":["3.2"],"它可以在后台标签页或隐藏的":["3.2"],"function":["3.3"],"callback":["3.3"],"获取当前时间":["3.3"],"now":["3.3"],"date":["3.3"],"是一次性的":["3.4"],"当你准备更新在屏动画时你应该调用此方法":["3.4"],"这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数":["3.4"],"即你的回调函数":["3.4"],"回调函数执行次数通常是每秒":["3.4"],"次":["3.4"],"但在大多数遵循":["3.4"],"该参数与":["3.6"],"是回调列表中唯一的标识":["3.7"],"密集型任务":["6.0"],"浏览器提供了":["6.0"],"web":["6.0"],"workers":["6.0"],"代码":["6.1"],"引擎线程运行会阻塞渲染线程的执行":["6.1"],"事件线程":["6.1"],"函数执行过程中":["6.2"],"如果触发了异步任务":["6.2"],"macro":["6.3"],"task":["6.3"],"事件交互":["6.4"],"回调函数被放入对应的微任务队列或宏任务队列中":["6.6"],"依次取出微任务队列中的回调函数直到清空":["6.6"],"可忽略":["6.7"],"执行网络请求":["6.7"],"文件读写等":["6.7"],"i":["6.7"],"o":["6.7"],"check":["6.7"],"执行":["6.7"],"setimmediate":["6.7"],"get":["6.8"],"httpbin":["6.8"],"org":["6.8"],"stream":["6.8"],"bytes":["6.8"],"chunk":["6.8"],"size":["6.8"]},{"4":["6.6"],"5":["6.6"],"6":["6.7"],"16":["3.3"],"因为定时器会一直执行":["3.0"],"即使浏览器处于后台或隐藏状态":["3.0"],"也会消耗资源和电池寿命":["3.0"],"最后":["3.0"],"来请求下一次动画帧":["3.1"],"从而形成一个循环":["3.1"],"否则":["3.1"],"动画只会执行一次":["3.1"],"iframe":["3.2"],"中暂停动画":["3.2"],"从而节省资源和电池寿命":["3.2"],"这是因为浏览器会根据页面的可见性来决定是否执行":["3.2"],"的回调函数":["3.2"],"计算下一次执行时间":["3.3"],"nexttime":["3.3"],"math":["3.3"],"max":["3.3"],"w3c":["3.4"],"建议的浏览器中":["3.4"],"回调函数执行次数通常与浏览器屏幕刷新次数相匹配":["3.4"],"为了提高性能和电池寿命":["3.4"],"在大多数浏览器里":["3.4"],"当":["3.4"],"运行在后台标签页或者隐藏的":["3.4"],"performance":["3.6"],"now":["3.6"],"是个非零值":["3.7"],"没有别的意义":["3.7"],"技术":["6.0"],"使用":["6.0"],"worker":["6.0"],"类创建独立线程":["6.0"],"node":["6.0"],"js":["6.0"],"负责处理用户输入和其它事件的触发和处理":["6.1"],"定时器线程":["6.1"],"setinterval":["6.1"],"与":["6.1"],"settimeout":["6.1"],"会将被触发的异步任务交给":["6.2"],"特定的线程处理":["6.2"],"queue":["6.3"],"和":["6.3"],"网络请求":["6.4"],"requestanimationframe":["6.4"],"对象会被包装称微任务":["6.5"],"mutationobserver":["6.5"],"取出宏任务队列中的一个回调函数执行":["6.6"],"依次取出微任务队列中的回调函数执行直到清空":["6.6"],"close":["6.7"],"事件回调":["6.7"],"如":["6.7"],"socket":["6.7"],"on":["6.7","6.8"],"cb":["6.7"],"response":["6.8"],"data":["6.8"],"console":["6.8"],"log":["6.8"],"end":["6.8"]},{"它不能保证动画的灵活性":["3.0"],"因为定时器的频率是固定的":["3.0"],"不能根据不同的设备和环境进行调整":["3.0"],"我们可以使用":["3.1"],"cancelanimationframe":["3.1"],"来取消已经请求的动画帧":["3.1"],"如果页面不可见":["3.2"],"那么回调函数就不会执行":["3.2"],"直到页面再次可见时恢复执行":["3.2"],"它可以避免动画和其他任务的冲突":["3.2"],"从而提高动画的稳定性":["3.2"],"这是因为":["3.2"],"返回定时器编号":["3.3"],"return":["3.3"],"settimeout":["3.3","6.8"],"执行回调函数":["3.3"],"里时":["3.4"],"会被暂停调用以提升性能和电池寿命":["3.4"],"domhighrestimestamp":["3.4"],"参数会传入回调方法中":["3.4"],"它指示当前被":["3.4"],"的返回值相同":["3.6"],"它表示":["3.6"],"你可以传这个值给":["3.7"],"window":["3.7"],"提供了对应的":["6.0"],"threads":["6.0"],"后者引用":["6.0"],"所在的线程":["6.1"],"用于计时并触发定时任务":["6.1"],"存储线程":["6.1"],"负责处理与存储相关的任务":["6.1"],"函数继续执行完成后正常出栈":["6.2"],"当异步操作完成需要执行回调函数时":["6.2"],"微任务队列":["6.3"],"micro":["6.3"],"用于在浏览器的下一帧渲染之前执行回调函数":["6.4"],"监听":["6.5"],"重复":["6.6"],"eventloop":["6.7"],"每个阶段都有一个对应的":["6.7"],"宏":["6.7"],"任务队列":["6.7"],"每个阶段都需要清空对应的任务队列":["6.7"],"执行完所有的回调函数":["6.7"],"事件循环才会进入下一个阶段":["6.7"],"中还有另外还有两个优先级更高的队列":["6.7"],"nexttick":["6.7"],"queue":["6.7"],"存放":["6.7"],"procee":["6.7"],"error":["6.8"],"err":["6.8"]},{"2000":["6.8"],"为了解决这些问题":["3.0"],"html5":["3.0"],"提供了一个新的方法":["3.0"],"传入的参数是":["3.1"],"的返回值":["3.1"],"表示动画帧的编号":["3.1"],"的回调函数会在浏览器的主线程中执行":["3.2"],"但是它会在其他任务":["3.2"],"如事件处理":["3.2"],"dom":["3.2","6.5"],"操作":["3.2"],"cancelanimationframe":["3.3","3.7"],"cleartimeout":["3.3"],"这个":["3.3"],"的原理是使用":["3.3"],"排序的回调函数被触发的时间":["3.4"],"在同一个帧中的多个回调函数":["3.4"],"它们每一个都会接受到一个相同的时间戳":["3.4"],"即使在计算上一个回调函数的工作负载期间已经消耗了一些时间":["3.4"],"该时间戳是一个十进制数":["3.4"],"单位为毫秒":["3.4"],"最小精度为":["3.4"],"1ms":["3.4"],"requestanimationframe":["3.6"],"开始执行回调函数的时刻":["3.6"],"以取消回调函数请求":["3.7"],"包创建独立线程":["6.0"],"这两种方案创建的独立线程":["6.0"],"可以与主线程通信":["6.0"],"从而利用多核":["6.0"],"如读取和写入本地存储":["6.1"],"网络线程":["6.1"],"负责处理网络请求和响应的发送和接收":["6.1"],"工作线程":["6.1"],"web":["6.1"],"特定的处理线程":["6.2"],"会将回调函数放入对应的任务队列":["6.2"],"它们分别用于存放微任务和宏任务的回调函数":["6.3"],"messagechannel":["6.4"],"用于跨线程异步通信":["6.4"],"变动的回调会被放入微任务队列":["6.5"],"步骤":["6.6"],"直至所有任务队列清空":["6.6"],"事件循环持续运行":["6.6"],"不断检查微任务队列和宏任务队列":["6.6"],"回调":["6.7"],"优先级最高":["6.7"],"某个阶段产生的":["6.7"],"回调会插入前阶段的末尾执行":["6.7"],"而不是下一个事件循环中":["6.7"],"microtask":["6.7"],"promise":["6.7"],"的":["6.7"],"适当调整":["6.8"],"延迟参数":["6.8"],"可以得到下面的结果":["6.8"]},{"60":["3.3"],"这个方法可以让浏览器在合适的时间来执行动画的回调函数":["3.0"],"从而实现流畅和高效的动画效果":["3.0"],"这样可以在不需要动画时停止动画":["3.1"],"节省资源":["3.1"],"网络请求等":["3.2"],"之后":["3.2"],"渲染之前执行":["3.2"],"这样可以保证动画的状态和渲染的一致性":["3.2"],"避免出现闪烁或抖动等问题":["3.2"],"来模拟":["3.3"],"但是它会根据上一次执行时间来计算下一次执行时间":["3.3"],"从而尽量保持每秒":["3.3"],"帧的效果":["3.3"],"1000μs":["3.4"],"warning":["3.4"],"警告":["3.4"],"请确保总是使用第一个参数":["3.4"],"或其他一些获取当前时间的方法":["3.4"],"来计算动画在一帧中的进度":["3.4"],"否则动画在高刷新率的屏幕中会运行得更快":["3.4"],"处理":["6.0"],"workers":["6.1"],"用于执行耗时的操作":["6.1"],"以避免阻塞主线程":["6.1"],"微任务队列执行的优先级高于宏任务队列":["6.3"],"每执行一次宏任务回调函数":["6.6"],"就需要清空所有微任务队列":["6.6"],"then":["6.7"],"catch":["6.7"],"行为类似":["6.7"],"优先级仅次于":["6.7"],"order":["6.7"],"但是如果":["6.8"],"事件的回调函数内有较复杂的费时操作":["6.8"],"还是会影响到定时器的准确性":["6.8"]}]'},t={"3.0":{t:"# requestAnimationFrame\r",p:`使用 setInterval() 或 setTimeout() 完成动画的核心是来定时更新动画的状态和渲染。
这种方法看起来 ...`,l:"性能优化/requestAnimationFrame.html",a:"requestanimationframe"},"3.1":{t:"用法\r",p:"requestAnimationFrame 的用法很简单，只需要传入一个回调函数作为参数，就可以让浏览器在下一次重绘之前执行 ...",l:"性能优化/requestAnimationFrame.html#用法",a:"用法"},"3.2":{t:"性能\r",p:`requestAnimationFrame 的性能优势主要体现在以下几个方面：

它可以根据浏览器的刷新率来调整动画帧率，从 ...`,l:"性能优化/requestAnimationFrame.html#性能",a:"性能"},"3.3":{t:"兼容性\r",p:"requestAnimationFrame 的兼容性还不是很好，目前只有最新版本的主流浏览器支持它。如果要在不支持的浏览器中 ...",l:"性能优化/requestAnimationFrame.html#兼容性",a:"兼容性"},"3.4":{t:"总结\r",p:"requestAnimationFrame 是一个非常有用的方法，可以让我们创建流畅和高效的动画效果。它有以下几个特点和优势 ...",l:"性能优化/requestAnimationFrame.html#总结",a:"总结"},"3.5":{t:"语法\r",p:`requestAnimationFrame(callback)

`,l:"性能优化/requestAnimationFrame.html#语法",a:"语法"},"3.6":{t:"参数\r",p:`callback
当你的动画需要更新时，为下一次重绘所调用的函数。该回调函数会传入 DOMHighResTimeStamp  ...`,l:"性能优化/requestAnimationFrame.html#参数",a:"参数"},"3.7":{t:"返回值\r",p:"一个 long 整数，请求 ID，是回调列表中唯一的标识。是个非零值，没有别的意义。你可以传这个值给 window.canc ...",l:"性能优化/requestAnimationFrame.html#返回值",a:"返回值"},"3.8":{t:"优点\r",p:`
电池友好

`,l:"性能优化/requestAnimationFrame.html#优点",a:"优点"},"6.0":{t:"# Event Loop\r",p:"ES 的运行环境都采用了单线程模型，这意味着任一时刻，ES 只能执行一个操作。单线程的好处是：不需要考虑并发和同步问题、避免 ...",l:"进阶篇/Event Loop.html",a:"event-loop"},"6.1":{t:"浏览器的事件循环\r",p:"在现代浏览器中，一个标签页通常是一个独立的进程，每个进程都可以包含多个线程。浏览器有一个主线程，负责处理子线程的协调和调度， ...",l:"进阶篇/Event Loop.html#浏览器的事件循环",a:"浏览器的事件循环"},"6.2":{t:"调用栈\r",p:`调用栈是一个用于追踪函数调用的有限栈内存区域。当函数被调用时，会被推入调用栈，当函数执行完成后，会从调用栈中弹出。
函数执行 ...`,l:"进阶篇/Event Loop.html#调用栈",a:"调用栈"},"6.3":{t:"任务队列\r",p:"任务队列是一个遵循先进先出原则的队列，在浏览器中，任务队列由浏览器内核或 ES 引擎创建和管理，浏览器中包含两个主要的任务队 ...",l:"进阶篇/Event Loop.html#任务队列",a:"任务队列"},"6.4":{t:"宏任务\r",p:`
定时器：setTimeout()、setInterval()
UI 事件交互
网络请求
requestAnimationF ...`,l:"进阶篇/Event Loop.html#宏任务",a:"宏任务"},"6.5":{t:"微任务\r",p:`
Promise
await：await 关键字后的 Promise 对象会被包装称微任务
MutationObserver ...`,l:"进阶篇/Event Loop.html#微任务",a:"微任务"},"6.6":{t:"事件循环过程\r",p:`
主线程（指 ES 引擎线程）执行同步任务，入栈、出栈直到调用栈为空。执行过程中的异步任务交由特定线程处理，异步操作执行完成 ...`,l:"进阶篇/Event Loop.html#事件循环过程",a:"事件循环过程"},"6.7":{t:"Node.js 的事件循环\r",p:"Node.js 事件循环由 libuv 库实现，Node.js 执行过程中的异步任务交由 libuv 处理，异步操作执行完成 ...",l:"进阶篇/Event Loop.html#node-js-的事件循环",a:"node-js-的事件循环"},"6.8":{t:"关于 `poll` 阶段\r",p:`在 poll 阶段，I/O 的回调函数可能持续触发，因此这个过程可能会阻塞后续阶段的回调执行。
为确保定时器的执行不会误差太 ...`,l:"进阶篇/Event Loop.html#关于-poll-阶段",a:"关于-poll-阶段"}},a={previewLength:62,buttonLabel:"Search",placeholder:"Search docs",allow:[],ignore:[]},n={INDEX_DATA:e,PREVIEW_LOOKUP:t,Options:a};export{n as default};
