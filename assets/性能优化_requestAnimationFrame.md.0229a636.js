import{_ as s,c as a,o as n,Q as e}from"./chunks/framework.1f725d55.js";const u=JSON.parse('{"title":"requestAnimationFrame","description":"","frontmatter":{},"headers":[],"relativePath":"性能优化/requestAnimationFrame.md","filePath":"性能优化/requestAnimationFrame.md","lastUpdated":1698052156000}'),l={name:"性能优化/requestAnimationFrame.md"},o=e(`<h1 id="requestanimationframe" tabindex="-1">requestAnimationFrame <a class="header-anchor" href="#requestanimationframe" aria-label="Permalink to &quot;requestAnimationFrame&quot;">​</a></h1><p>使用 <code>setInterval()</code> 或 <code>setTimeout()</code> 完成动画的核心是来定时更新动画的状态和渲染。</p><p>这种方法看起来很简单，但实际上有很多问题。首先，它不能保证动画的流畅性，因为定时器的执行时间和浏览器的渲染时间可能不一致，导致动画出现卡顿或掉帧的现象。其次，它不能保证动画的高效性，因为定时器会一直执行，即使浏览器处于后台或隐藏状态，也会消耗资源和电池寿命。最后，它不能保证动画的灵活性，因为定时器的频率是固定的，不能根据不同的设备和环境进行调整。</p><p>为了解决这些问题，HTML5 提供了一个新的方法：requestAnimationFrame。这个方法可以让浏览器在合适的时间来执行动画的回调函数，从而实现流畅和高效的动画效果。</p><h2 id="用法" tabindex="-1">用法 <a class="header-anchor" href="#用法" aria-label="Permalink to &quot;用法&quot;">​</a></h2><p>requestAnimationFrame 的用法很简单，只需要传入一个回调函数作为参数，就可以让浏览器在下一次重绘之前执行这个回调函数。例如，我们可以使用以下代码来改写上面的移动方块的动画：</p><p>这里有几点需要注意：</p><ul><li>回调函数会接收一个参数：timestamp，表示当前时间与页面加载时间的差值（单位为毫秒）。我们可以利用这个参数来计算动画的状态和速度。</li><li>我们需要在回调函数中再次调用 requestAnimationFrame 来请求下一次动画帧，从而形成一个循环。否则，动画只会执行一次。</li><li>我们可以使用 cancelAnimationFrame 来取消已经请求的动画帧，传入的参数是 requestAnimationFrame 的返回值，表示动画帧的编号。这样可以在不需要动画时停止动画，节省资源。</li></ul><h2 id="性能" tabindex="-1">性能 <a class="header-anchor" href="#性能" aria-label="Permalink to &quot;性能&quot;">​</a></h2><p>requestAnimationFrame 的性能优势主要体现在以下几个方面：</p><ul><li>它可以根据浏览器的刷新率来调整动画帧率，从而保证动画的流畅性。一般来说，浏览器的刷新率是 60Hz，也就是每秒 60 帧，所以 requestAnimationFrame 的回调函数也会每秒执行 60 次。但是，如果浏览器的刷新率低于 60Hz，或者设备的性能不足，那么 requestAnimationFrame 的回调函数会相应地减少执行次数，以避免动画卡顿或掉帧。</li><li>它可以在后台标签页或隐藏的 &lt;iframe&gt; 中暂停动画，从而节省资源和电池寿命。这是因为浏览器会根据页面的可见性来决定是否执行 requestAnimationFrame 的回调函数。如果页面不可见，那么回调函数就不会执行，直到页面再次可见时恢复执行。</li><li>它可以避免动画和其他任务的冲突，从而提高动画的稳定性。这是因为 requestAnimationFrame 的回调函数会在浏览器的主线程中执行，但是它会在其他任务（如事件处理，DOM 操作，网络请求等）之后，渲染之前执行。这样可以保证动画的状态和渲染的一致性，避免出现闪烁或抖动等问题。</li></ul><h2 id="兼容性" tabindex="-1">兼容性 <a class="header-anchor" href="#兼容性" aria-label="Permalink to &quot;兼容性&quot;">​</a></h2><p>requestAnimationFrame 的兼容性还不是很好，目前只有最新版本的主流浏览器支持它。如果要在不支持的浏览器中使用它，我们需要使用 polyfill 来模拟它。polyfill 是一种代码片段，可以让旧版本的浏览器支持新的特性或方法。</p><p>一个简单的 requestAnimationFrame 的 polyfill 如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 判断是否已经存在 requestAnimationFrame</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">window.requestAnimationFrame) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 定义变量</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> lastTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 创建 requestAnimationFrame</span></span>
<span class="line"><span style="color:#E1E4E8;">  window.</span><span style="color:#B392F0;">requestAnimationFrame</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">callback</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取当前时间</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> now </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Date.</span><span style="color:#B392F0;">now</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 计算下一次执行时间</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> nextTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(lastTime </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">16</span><span style="color:#E1E4E8;">, now);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 返回定时器编号</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 执行回调函数</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">callback</span><span style="color:#E1E4E8;">(lastTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextTime);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }, nextTime </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> now);</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 创建 cancelAnimationFrame</span></span>
<span class="line"><span style="color:#E1E4E8;">  window.cancelAnimationFrame </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> clearTimeout;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 判断是否已经存在 requestAnimationFrame</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">window.requestAnimationFrame) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 定义变量</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> lastTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 创建 requestAnimationFrame</span></span>
<span class="line"><span style="color:#24292E;">  window.</span><span style="color:#6F42C1;">requestAnimationFrame</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">callback</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取当前时间</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> now </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Date.</span><span style="color:#6F42C1;">now</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 计算下一次执行时间</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> nextTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(lastTime </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">16</span><span style="color:#24292E;">, now);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 返回定时器编号</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 执行回调函数</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">callback</span><span style="color:#24292E;">(lastTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextTime);</span></span>
<span class="line"><span style="color:#24292E;">    }, nextTime </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> now);</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 创建 cancelAnimationFrame</span></span>
<span class="line"><span style="color:#24292E;">  window.cancelAnimationFrame </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> clearTimeout;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这个 polyfill 的原理是使用 setTimeout 来模拟 requestAnimationFrame，但是它会根据上一次执行时间来计算下一次执行时间，从而尽量保持每秒 60 帧的效果。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>requestAnimationFrame 是一个非常有用的方法，可以让我们创建流畅和高效的动画效果。它有以下几个特点和优势：</p><ul><li>它可以根据浏览器的刷新率来调整动画帧率，保证动画的流畅性。</li><li>它可以在后台标签页或隐藏的 &lt;iframe&gt; 中暂停动画，节省资源和电池寿命。</li><li>它可以</li></ul><p><code>window.requestAnimationFrame()</code> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p><div class="tip custom-block"><p class="custom-block-title">备注</p><p>若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 <code>requestAnimationFrame()</code>。<code>requestAnimationFrame()</code> 是一次性的。</p></div><p>当你准备更新在屏动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数（即你的回调函数）。回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。为了提高性能和电池寿命，在大多数浏览器里，当 <code>requestAnimationFrame()</code> 运行在后台标签页或者隐藏的 &lt;iframe&gt; 里时，<code>requestAnimationFrame()</code> 会被暂停调用以提升性能和电池寿命。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp" target="_blank" rel="noreferrer"><code>DOMHighResTimeStamp</code></a> 参数会传入回调方法中，它指示当前被 <code>requestAnimationFrame()</code> 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位为毫秒，最小精度为 1ms（1000μs）。</p><div class="warning custom-block"><p class="custom-block-title">警告</p><p>请确保总是使用第一个参数（或其他一些获取当前时间的方法）来计算动画在一帧中的进度，否则动画在高刷新率的屏幕中会运行得更快。</p></div><h2 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">requestAnimationFrame</span><span style="color:#E1E4E8;">(callback)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">requestAnimationFrame</span><span style="color:#24292E;">(callback)</span></span></code></pre></div><h3 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to &quot;参数&quot;">​</a></h3><p><code>callback</code></p><p>当你的动画需要更新时，为下一次重绘所调用的函数。该回调函数会传入 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp" target="_blank" rel="noreferrer"><code>DOMHighResTimeStamp</code></a> 参数，该参数与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now" target="_blank" rel="noreferrer"><code>performance.now()</code></a> 的返回值相同，它表示 <code>requestAnimationFrame()</code> 开始执行回调函数的时刻。</p><h3 id="返回值" tabindex="-1">返回值 <a class="header-anchor" href="#返回值" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>一个 <code>long</code> 整数，请求 ID，是回调列表中唯一的标识。是个非零值，没有别的意义。你可以传这个值给 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame" target="_blank" rel="noreferrer"><code>window.cancelAnimationFrame()</code></a> 以取消回调函数请求。</p><h2 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h2><ul><li>电池友好</li></ul>`,33),p=[o];function t(r,c,i,E,y,m){return n(),a("div",null,p)}const A=s(l,[["render",t]]);export{u as __pageData,A as default};
